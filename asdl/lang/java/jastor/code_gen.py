# -*- coding: utf-8 -*-
"""
Part of the astor library for Python AST manipulation.

License: 3-clause BSD

Copyright (c) 2008      Armin Ronacher
Copyright (c) 2012-2017 Patrick Maupin
Copyright (c) 2013-2017 Berker Peksag

This module converts an AST into Python source code.

Before being version-controlled as part of astor,
this code came from here (in 2012):

    https://gist.github.com/1250562

"""

from javalang.ast import Node
import math
import sys

from .op_util import get_op_symbol, get_op_precedence, Precedence
from .node_util import ExplicitNodeVisitor
from .string_repr import pretty_string, string_triplequote_repr
from .source_repr import pretty_source


def to_source(node, indent_with=' ' * 4, add_line_information=False,
              pretty_string=pretty_string, pretty_source=pretty_source):
    """This function can convert a node tree back into python sourcecode.
    This is useful for debugging purposes, especially if you're dealing with
    custom asts not generated by python itself.

    It could be that the sourcecode is evaluable when the AST itself is not
    compilable / evaluable.  The reason for this is that the AST contains some
    more data than regular sourcecode does, which is dropped during
    conversion.

    Each level of indentation is replaced with `indent_with`.  Per default this
    parameter is equal to four spaces as suggested by PEP 8, but it might be
    adjusted to match the application's styleguide.

    If `add_line_information` is set to `True` comments for the line numbers
    of the nodes are added to the output.  This can be used to spot wrong line
    number information of statement nodes.

    """
    generator = SourceGenerator(indent_with, add_line_information,
                                pretty_string)
    generator.visit(node)
    generator.result.append('\n')
    if set(generator.result[0]) == set('\n'):
        generator.result[0] = ''
    return pretty_source(generator.result)


def precedence_setter(AST=Node, get_op_precedence=get_op_precedence,
                      isinstance=isinstance, list=list):
    """ This only uses a closure for performance reasons,
        to reduce the number of attribute lookups.  (set_precedence
        is called a lot of times.)
    """

    def set_precedence(value, *nodes):
        """Set the precedence (of the parent) into the children.
        """
        if isinstance(value, Node):
            value = get_op_precedence(value)
        for node in nodes:
            if isinstance(node, Node):
                node._pp = value
            elif isinstance(node, list):
                set_precedence(value, *node)
            else:
                assert node is None, node

    return set_precedence


set_precedence = precedence_setter()


class Delimit(object):
    """A context manager that can add enclosing
       delimiters around the output of a
       SourceGenerator method.  By default, the
       parentheses are added, but the enclosed code
       may set discard=True to get rid of them.
    """

    discard = False

    def __init__(self, tree, *args):
        """ use write instead of using result directly
            for initial data, because it may flush
            preceding data into result.
        """
        delimiters = '()'
        node = None
        op = None
        for arg in args:
            if isinstance(arg, Node):
                if node is None:
                    node = arg
                else:
                    op = arg
            else:
                delimiters = arg
        tree.write(delimiters[0])
        result = self.result = tree.result
        self.index = len(result)
        self.closing = delimiters[1]
        if node is not None:
            self.p = p = get_op_precedence(op or node)
            self.pp = pp = tree.get__pp(node)
            self.discard = p >= pp

    def __enter__(self):
        return self

    def __exit__(self, *exc_info):
        result = self.result
        start = self.index - 1
        if self.discard:
            result[start] = ''
        else:
            result.append(self.closing)


class SourceGenerator(ExplicitNodeVisitor):
    """This visitor is able to transform a well formed syntax tree into Python
    sourcecode.

    For more details have a look at the docstring of the `node_to_source`
    function.

    """

    using_unicode_literals = False

    def __init__(self, indent_with, add_line_information=False,
                 pretty_string=pretty_string,
                 # constants
                 len=len, isinstance=isinstance, callable=callable):
        self.result = []
        self.indent_with = indent_with
        self.add_line_information = add_line_information
        self.indentation = 0  # Current indentation level
        self.new_lines = 0  # Number of lines to insert before next code
        self.colinfo = 0, 0  # index in result of string containing linefeed, and
                             # position of last linefeed in that string
        self.pretty_string = pretty_string
        AST = Node

        visit = self.visit
        newline = self.newline
        result = self.result
        append = result.append

        def write(*params):
            """ self.write is a closure for performance (to reduce the number
                of attribute lookups).
            """
            for item in params:
                if isinstance(item, AST):
                    visit(item)
                elif callable(item):
                    item()
                elif item == '\n':
                    newline()
                else:
                    if self.new_lines:
                        append('\n' * self.new_lines)
                        self.colinfo = len(result), 0
                        append(self.indent_with * self.indentation)
                        self.new_lines = 0
                    if item:
                        append(item)

        self.write = write

    def __getattr__(self, name, defaults=dict(keywords=(),
                    _pp=Precedence.highest).get):
        """ Get an attribute of the node.
            like dict.get (returns None if doesn't exist)
        """
        if not name.startswith('get_'):
            raise AttributeError
        geta = getattr
        shortname = name[4:]
        default = defaults(shortname)

        def getter(node):
            return geta(node, shortname, default)

        setattr(self, name, getter)
        return getter

    def delimit(self, *args):
        return Delimit(self, *args)

    def conditional_write(self, *stuff):
        if stuff[-1] is not None:
            self.write(*stuff)
            # Inform the caller that we wrote
            return True

    def newline(self, node=None, extra=0):
        self.new_lines = max(self.new_lines, 1 + extra)
        if node is not None and self.add_line_information:
            self.write('# line: %s' % node.lineno)
            self.new_lines = 1

    def visit_arguments(self, node):
        want_comma = []

        def write_comma():
            if want_comma:
                self.write(', ')
            else:
                want_comma.append(True)

        def loop_args(args, defaults):
            set_precedence(Precedence.Comma, defaults)
            padding = [None] * (len(args) - len(defaults))
            for arg, default in zip(args, padding + defaults):
                self.write(write_comma, arg)
                self.conditional_write('=', default)

        loop_args(node.args, node.defaults)
        self.conditional_write(write_comma, '*', node.vararg)

        kwonlyargs = self.get_kwonlyargs(node)
        if kwonlyargs:
            if node.vararg is None:
                self.write(write_comma, '*')
            loop_args(kwonlyargs, node.kw_defaults)
        self.conditional_write(write_comma, '**', node.kwarg)

    def statement(self, node, *params, **kw):
        self.newline(node)
        self.write(*params)

    def decorators(self, node, extra):
        self.newline(extra=extra)
        for decorator in node.decorator_list:
            self.statement(decorator, '@', decorator)

    def comma_list(self, items, trailing=False):
        set_precedence(Precedence.Comma, *items)
        for idx, item in enumerate(items):
            self.write(', ' if idx else '', item)
        self.write(',' if trailing else '')

    # Statements

    def visit_CompilationUnit(self, node):
        for attr, child in zip(node.attrs, node.children):
            if attr == 'package':
                self.write(child)
            elif attr in ['imports', 'types']:
                for element in child:
                    self.write(element)

    def visit_Annotation(self, node):
        self.write('@', node.name, ' ')

    def visit_PackageDeclaration(self, node):
        for attr, child in zip(node.attrs, node.children):
            if attr in ['modifiers', 'annotations'] and child is not None:
                for element in child:
                    self.write(element)
            elif attr == 'documentation' and child is not None:
                self.write(child)
            elif attr == 'name':
                self.write('package ', child, ';')

    def visit_ClassDeclaration(self, node):
        for attr, child in zip(node.attrs, node.children):
            if attr == 'documentation' and child is not None:
                self.write(child)
            elif attr in ['modifiers', 'annotations'] and child is not None:
                for element in child:
                    self.write(element)
            elif attr == 'type_parameters' and child:
                self.comma_list(child)
            elif attr == 'extends' and child is not None:
                self.write('extends ', child)
            elif attr == 'implements' and child:
                self.write('implements ')
                self.comma_list(child)
            elif attr == 'name':
                self.write(' class ', child)
            elif attr == 'body':
                self.write(' {')
                for element in child:
                    self.write(element)
                self.write('}')

    def visit_TypeArgument(self, node):
        raise Exception("TODO")

    def visit_MethodDeclaration(self, node):
        for attr, child in zip(node.attrs, node.children):
            if attr == 'documentation' and child is not None:
                self.write(child)
            elif attr in ['modifiers', 'annotations'] and child is not None:
                for element in child:
                    self.write(element, " ")
            elif attr == 'type_parameters' and child:
                self.comma_list(child)
            elif attr == 'return_type':
                if child is None:
                    self.write("void ")
                else:
                    self.write(child, " ")
            elif attr == 'name':
                self.write(child)
            elif attr == 'parameters' and child:
                self.write('(')
                self.comma_list(child)
                self.write(')')
            elif attr == 'throws' and child:
                self.write(' throws ', child)
            elif attr == 'body':
                self.write(' {')
                for element in child:
                    self.write(element)
                self.write('}')

    def visit_FieldDeclaration(self, node):
        self.write(" ", node.type)
        self.comma_list(node.declarators)
        self.write("; ")

    def visit_ReferenceType(self, node):
        self.write(node.name)
        for _ in range(len(node.dimensions)):
            self.write("[]")

    def visit_VariableDeclarator(self, node):
        self.write(" ", node.name)
        self.write(" = ", node.initializer)

    def visit_Literal(self, node):
        for op in node.prefix_operators:
            self.write(op)
        if node.qualifier:
            self.write(node.qualifier, ".")
        self.write(node.value)
        for selector in node.selectors:
            self.write(selector)
        for op in node.postfix_operators:
            self.write(op)

    def visit_FormalParameter(self, node):
        for attr, child in zip(node.attrs, node.children):
            if attr in ['modifiers', 'annotations'] and child is not None:
                for element in child:
                    self.write(element, " ")
            elif attr == 'type' and child:
                self.write(child)
            elif attr == 'name':
                self.write(" ", child)
            #elif attr == 'varargs' and child:
                #self.write(child)

    def visit_StatementExpression(self, node):
        if node.label:
            self.write(node.label, " ")
        self.write(node.expression, ";")

    def visit_TernaryExpression(self, node):
        self.write(node.condition, " ? ", node.if_true, " : ", node.if_false)

    def visit_MethodInvocation(self, node):
        for op in node.prefix_operators:
            self.write(op)
        if node.qualifier:
            self.write(node.qualifier, ".")
        self.write(node.member)
        if node.type_arguments:
            self.comma_list(node.type_arguments)
        for selector in node.selectors:
            self.write(selector)
        self.write("(")
        self.comma_list(node.arguments)
        self.write(")")
        for op in node.postfix_operators:
            self.write(op)

    def visit_ForStatement(self, node):
        self.write("for (")
        self.write(node.control)
        self.write(") ")
        self.write(node.body)

    def visit_ForControl(self, node):
        self.write(node.init)
        self.write("; ")
        self.write(node.condition)
        self.write("; ")
        self.comma_list(node.update)

    def visit_VariableDeclaration(self, node):
        self.write(node.type, " ")
        self.comma_list(node.declarators)

    def visit_BinaryOperation(self, node):
        self.write(node.operandl)
        # self.write(" ", get_op_symbol(node.operator, ' %s '), " ")
        self.write(" ", node.operator, " ")
        self.write(node.operandr)

    def visit_MemberReference(self, node):
        for op in node.prefix_operators:
            # self.write(get_op_symbol(op, ' %s '))
            self.write(op.operator)
        if node.qualifier:
            self.write(node.qualifier, ".")
        self.write(node.member)
        for selector in node.selectors:
            self.write(selector)
        for op in node.postfix_operators:
            # self.write(get_op_symbol(op, ' %s '))
            self.write(op.operator)

    def visit_BasicType(self, node):
        self.write(node.name)
        for _ in range(len(node.dimensions)):
            self.write("[]")

    def visit_Void(self, node):
        self.write("void")

    def visit_ArraySelector(self, node):
        self.write("[", node.index, "]")

    def visit_Modifier(self, node):
        self.write(node.value, " ")

    def visit_LocalVariableDeclaration(self, node):
        # ['modifiers', 'annotations', 'type', 'declarators']
        for attr, child in zip(node.attrs, node.children):
            if attr in ['modifiers', 'annotations'] and child is not None:
                for element in child:
                    self.write(element, " ")
            elif attr == 'type' and child:
                self.write(child)
            elif attr == 'declarators':
                self.comma_list(node.declarators)
        self.write(';')

    def visit_Operator(self, node):
        self.write(node.operator)

    # Import(identifier path, identifier static, identifier wildcard)
    def visit_Import(self, node):
        self.write('import ')
        if node.static:
            self.write('static ')
        self.write(node.path)
        if node.wildcard:
            self.write('.*', ';', '\n')

    # Assignment(expression expressionl, expression value, assign_operator type)
    def visit_Assignment(self, node):
        raise Exception("TODO Assignment")

    # InferredFormalParameter(identifier name)
    def visit_InferredFormalParameter(self, node):
        raise Exception("TODO InferredFormalParameter")

    # ReturnStatement(identifier* label, expression expression)
    def visit_ReturnStatement(self, node):
        raise Exception("TODO ReturnStatement")

    # IfStatement(identifier? label, expression condition, statement then_statement, statement else_statement)
    def visit_IfStatement(self, node):
        raise Exception("TODO IfStatement")

    # BlockStatement(identifier? label, statement* statements)
    def visit_BlockStatement(self, node):
        raise Exception("TODO BlockStatement")

    # TryStatement(identifier? label, identifier? resources, statement* block, catch* catches, statement? finally_block)
    def visit_TryStatement(self, node):
        raise Exception("TODO TryStatement")

    # ThrowStatement(identifier* label, expression expression)
    def visit_ThrowStatement(self, node):
        raise Exception("TODO ThrowStatement")

    # CatchClause(identifier? label, catch_clause_parameter parameter, statement* block)
    def visit_CatchClause(self, node):
        raise Exception("TODO CatchClause")

    # CatchClauseParameter(fieldmodifier* modifiers, annotation* annotations, identifier* types, identifier name)
    def visit_CatchClauseParameter(self, node):
        raise Exception("TODO CatchClauseParameter")

    # EnhancedForControl(expression var, statement iterable)
    def visit_EnhancedForControl(self, node):
        raise Exception("TODO EnhancedForControl")

    # This(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selector* selectors)
    def visit_This(self, node):
        raise Exception("TODO This")

    # Cast(type type, expression expression)
    def visit_Cast(self, node):
        raise Exception("TODO Cast")

    # MethodReference(expression expression, identifier method, type_argument* type_arguments)
    def visit_MethodReference(self, node):
        raise Exception("TODO MethodReference")

    # LambdaExpression(parameter* parameters, statement body)
    def visit_LambdaExpression(self, node):
        raise Exception("TODO LambdaExpression")

    # Primary(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selector* selectors)
    def visit_Primary(self, node):
        raise Exception("TODO Primary")

    # ExplicitConstructorInvocation(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selector* selectors, type_argument* type_arguments, argument* arguments)
    def visit_ExplicitConstructorInvocation(self, node):
        raise Exception("TODO ExplicitConstructorInvocation")


    # SuperConstructorInvocation(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selector* selectors, type_argument* type_arguments, argument* arguments)
    def visit_SuperConstructorInvocation(self, node):
        raise Exception("TODO ExplicitConstructorInvocation")

        for op in node.prefix_operators:
            self.write(op)
        if node.qualifier:
            self.write(node.qualifier, ".")
        self.write(node.member)
        if node.type_arguments:
            self.comma_list(node.type_arguments)
        for selector in node.selectors:
            self.write(selector)
        self.write("(")
        self.comma_list(node.arguments)
        self.write(")")
        for op in node.postfix_operators:
            self.write(op)
