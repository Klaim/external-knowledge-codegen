## ASDL's 4 builtin types are
identifier, int, string, constant

# package javalang.brewtab.com; class Test {}
#
# CompilationUnit(
#   imports=[],
#   package=PackageDeclaration(
#     annotations=None,
#     documentation=None,
#     modifiers=None,
#     name=javalang.brewtab.com),
#   types=[
#     ClassDeclaration(
#       annotations=[],
#       body=[],
#       documentation=None,
#       extends=None,
#       implements=None,
#       modifiers=set(),
#       name=Test,
#       type_parameters=None
#     )
#   ]
# )

cu = CompilationUnit(package? package, importdeclaration* imports, typedeclaration* types)

package = PackageDeclaration(packagemodifier* modifiers, identifier name)

importdeclaration = SingleTypeImportDeclaration(dottedname name)
      | TypeImportOnDemandDeclaration(dottedname name)
      | SingleStaticImportDeclaration(dottedname name, dotop op, identifier id)
      | StaticImportOnDemandDeclaration(dottedname name)

packagemodifier = PackageModifier(annotation annot)

dottedname = Identifier(identifier id)
      | PackageOrTypeName(dottedname left, dotop op, identifier right)
dotop = Dot

typedeclaration = ClassDeclaration(annotation* annotations, classbodydeclaration* body, string? documentation, dottedname? extends, dottedname* implements, fieldmodifier* modifiers, identifier name, type_parameter* type_parameters)
      | InterfaceDeclaration(interfacedeclaration id)
      | EnumDeclaration(classmodifier* cm, identifier id, superinterfaces si, enumbody eb)


classbodydeclaration = ClassMemberDeclaration(classmemberdeclaration cmd)
      | InstanceInitializer(instanceinitializer ii)
      | StaticInitializer(staticinitializer si)
      | ConstructorDeclaration(constructordeclaration constructordeclaration)
      | MethodDeclaration(string? documentation, fieldmodifier* modifiers, annotation* annotations, type_parameter* type_parameters, identifier return_type, identifier name, parameter* parameters, throw? throws, statement* body)
      | FieldDeclaration(string? documentation, fieldmodifier* modifiers, annotation* annotations, type type, declarator* declarators)

fieldmodifier = Modifier(constant value)

parameter = FormalParameter(annotation* annotations, fieldmodifier* modifiers, identifier name, type type, constant varargs)

statement = ForStatement(identifier? label, forcontrol control, statement body)
      | MethodInvocation(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selector* selectors, type_argument* type_arguments, argument* arguments, identifier member)
      | StatementExpression(identifier? label, statement expression)

forcontrol = ForControl(expression init, expression condition, expression* update)
#      | EnhancedForControl(var, iterable)


expression = VariableDeclaration(fieldmodifier* modifiers, annotation* annotations, type type, declarator* declarators)
      | Literal(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selector* selectors, string value)
      | BinaryOperation(constant operator, member_reference operandl, member_reference operandr)
      | MemberReference(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selector* selectors, identifier member)
      | TernaryExpression(expression condition, expression if_true, expression if_false)
      | ArraySelector(expression index)
#      | Assignment(expressionl, value, type)
#      | Cast(type, expression)
#      | MethodReference(expression, method, type_arguments)
#      | LambdaExpression(parameters, body)
#      | Primary(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selectors)
#      | This(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selectors)
#      | Invocation(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selectors, type_arguments, arguments)
#      | ExplicitConstructorInvocation(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selectors, type_arguments, arguments)
#      | SuperConstructorInvocation(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selectors, type_arguments, arguments)
#      | MethodInvocation(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selectors, type_arguments, arguments, member)
#      | SuperMethodInvocation(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selectors, type_arguments, arguments, member)
#      | SuperMemberReference(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selectors, member)
#      | ClassReference(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selectors, type)
#      | VoidClassReference(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selectors, type)
#      | Creator(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selectors, type)
#      | ArrayCreator(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selectors, type, int* dimensions, initializer)
#      | ClassCreator(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selectors, type, constructor_type_arguments, arguments, body)
#      | InnerClassCreator(prefix_operator* prefix_operators, postfix_operator* postfix_operators, identifier? qualifier, selectors, type, constructor_type_arguments, arguments, body)

type = BasicType(identifier name, int* dimensions)
      | ReferenceType(identifier name, int* dimensions, type_argument* arguments, identifier? sub_type)

declarator = VariableDeclarator(identifier name, int* dimensions, expression initializer)

type_argument = TypeArgument(identifier type, identifier pattern_type)

boolean = True | False

infix_operator = Or | And, BitOr | BitAnd | BitEx | Eq | Ne | Lt | Gt | Le | Ge | LeftShift | RightShift | ZeroFillRightShift | Plus | Minus | Mult | Div | Mod

prefix_operator = PreInc | PreDec | Not | BinNot | PrePlus | PreMinus

postfix_operator = PostInc | PostDec

assign_operator = Assisn | AssignInc | AssignDec | AssignMult | AssignDiv | AssignBitAnd | AssignBitOr | AssignBitEx | AssignMod | AssignLeftShift | AssignRightShift | AssignZeroFillRightShift

LAMBDA = Lambda
METHOD_REFERENCE = MethodReference

# ------------------------------------------------------------------------------

#class TypeParameter(Node):
#    attrs = ("name", "extends")







annotation = NormalAnnotation(typename name, elementvaluepairlist values)
elementvaluepairlist = ElementValuePairList(elementvaluepair* elmsts)
elementvaluepair = ElementValuePair(identifier id, elementvalue val)
elementvalue = ConditionalExpression(conditionalexpression ce)
      | ElementValueArrayInitializer(elementvalue* evl)
      | Annotation(annotation annot)



#Block:
  #{ [BlockStatements] }
#BlockStatements:
  #BlockStatement {BlockStatement}
#BlockStatement:
  #LocalVariableDeclarationStatement
  #ClassDeclaration
  #Statement
#LocalVariableDeclarationStatement:
  #LocalVariableDeclaration ;
#LocalVariableDeclaration:
  #{VariableModifier} UnannType VariableDeclaratorList
#Statement:
  #StatementWithoutTrailingSubstatement
  #LabeledStatement
  #IfThenStatement
  #IfThenElseStatement
  #WhileStatement
  #ForStatement
#StatementNoShortIf:
  #StatementWithoutTrailingSubstatement
  #LabeledStatementNoShortIf
  #IfThenElseStatementNoShortIf
  #WhileStatementNoShortIf
  #ForStatementNoShortIf
#StatementWithoutTrailingSubstatement:
  #Block
  #EmptyStatement
  #ExpressionStatement
  #AssertStatement
  #SwitchStatement
  #DoStatement
  #BreakStatement
  #ContinueStatement
  #ReturnStatement
  #SynchronizedStatement
  #ThrowStatement
  #TryStatement
#EmptyStatement:
  #;
#LabeledStatement:
  #Identifier : Statement
#LabeledStatementNoShortIf:
  #Identifier : StatementNoShortIf
#ExpressionStatement:
  #StatementExpression ;
#StatementExpression:
  #Assignment
  #PreIncrementExpression
  #PreDecrementExpression
  #PostIncrementExpression
  #PostDecrementExpression
  #MethodInvocation
  #ClassInstanceCreationExpression
#IfThenStatement:
  #if ( Expression ) Statement
#IfThenElseStatement:
  #if ( Expression ) StatementNoShortIf else Statement
#IfThenElseStatementNoShortIf:
  #if ( Expression ) StatementNoShortIf else StatementNoShortIf
#AssertStatement:
  #assert Expression ;
  #assert Expression : Expression ;
#SwitchStatement:
  #switch ( Expression ) SwitchBlock
#SwitchBlock:
  #{ {SwitchBlockStatementGroup} {SwitchLabel} }
#SwitchBlockStatementGroup:
  #SwitchLabels BlockStatements
#SwitchLabels:
  #SwitchLabel {SwitchLabel}
#SwitchLabel:
  #case ConstantExpression :
  #case EnumConstantName :
  #default :
#EnumConstantName:
  #Identifier
#WhileStatement:
  #while ( Expression ) Statement
#WhileStatementNoShortIf:
  #while ( Expression ) StatementNoShortIf
#DoStatement:
  #do Statement while ( Expression ) ;
#ForStatement:
  #BasicForStatement
  #EnhancedForStatement
#ForStatementNoShortIf:
  #BasicForStatementNoShortIf
  #EnhancedForStatementNoShortIf
#BasicForStatement:
  #for ( [ForInit] ; [Expression] ; [ForUpdate] ) Statement
#BasicForStatementNoShortIf:
  #for ( [ForInit] ; [Expression] ; [ForUpdate] ) StatementNoShortIf
#ForInit:
  #StatementExpressionList
  #LocalVariableDeclaration
#ForUpdate:
  #StatementExpressionList
#StatementExpressionList:
  #StatementExpression {, StatementExpression}
#EnhancedForStatement:
  #for ( {VariableModifier} UnannType VariableDeclaratorId : Expression ) Statement
#EnhancedForStatementNoShortIf:
  #for ( {VariableModifier} UnannType VariableDeclaratorId : Expression ) StatementNoShortIf
#BreakStatement:
  #break [Identifier] ;
#ContinueStatement:
  #continue [Identifier] ;
#ReturnStatement:
  #return [Expression] ;
#ThrowStatement:
  #throw Expression ;
#SynchronizedStatement:
  #synchronized ( Expression ) Block
#TryStatement:
  #try Block Catches
#try Block [Catches] Finally
  #TryWithResourcesStatement
#Catches:
  #CatchClause {CatchClause}
#CatchClause:
  #catch ( CatchFormalParameter ) Block
#CatchFormalParameter:
  #{VariableModifier} CatchType VariableDeclaratorId
#CatchType:
  #UnannClassType {| ClassType}
#Finally:
  #finally Block
#TryWithResourcesStatement:
  #try ResourceSpecification Block [Catches] [Finally]
#ResourceSpecification:
  #( ResourceList [;] )
#ResourceList:
  #Resource {; Resource}
#Resource:
  #{VariableModifier} UnannType VariableDeclaratorId = Expression

#Primary:
  #PrimaryNoNewArray
  #ArrayCreationExpression
#PrimaryNoNewArray:
  #Literal
  #ClassLiteral
  #this
  #TypeName . this
  #( Expression )
  #ClassInstanceCreationExpression
  #FieldAccess
  #ArrayAccess
  #MethodInvocation
  #MethodReference
#ClassLiteral:
  #TypeName {[ ]} . class
  #NumericType {[ ]} . class
  #boolean {[ ]} . class
  #void . class
#ClassInstanceCreationExpression:
  #UnqualifiedClassInstanceCreationExpression
  #ExpressionName . UnqualifiedClassInstanceCreationExpression
  #Primary . UnqualifiedClassInstanceCreationExpression
#UnqualifiedClassInstanceCreationExpression:
  #new [TypeArguments] ClassOrInterfaceTypeToInstantiate ( [ArgumentList] ) [ClassBody]
#ClassOrInterfaceTypeToInstantiate:
  #{Annotation} Identifier {. {Annotation} Identifier} [TypeArgumentsOrDiamond]
#TypeArgumentsOrDiamond:
  #TypeArguments
  #<>
#FieldAccess:
  #Primary . Identifier
  #super . Identifier
  #TypeName . super . Identifier
#ArrayAccess:
  #ExpressionName [ Expression ]
  #PrimaryNoNewArray [ Expression ]
#MethodName:
  #Identifier
#MethodInvocation:
  #MethodName ( [ArgumentList] )
  #TypeName . [TypeArguments] Identifier ( [ArgumentList] )
  #ExpressionName . [TypeArguments] Identifier ( [ArgumentList] )
  #Primary . [TypeArguments] Identifier ( [ArgumentList] )
  #super . [TypeArguments] Identifier ( [ArgumentList] )
  #TypeName . super . [TypeArguments] Identifier ( [ArgumentList] )
#ArgumentList:
  #Expression {, Expression}
#MethodReference:
  #ExpressionName :: [TypeArguments] Identifier
  #ReferenceType :: [TypeArguments] Identifier
  #Primary :: [TypeArguments] Identifier
  #super :: [TypeArguments] Identifier
  #TypeName . super :: [TypeArguments] Identifier
  #ClassType :: [TypeArguments] new
  #ArrayType :: new
#ArrayCreationExpression:
  #new PrimitiveType DimExprs [Dims]
  #new ClassOrInterfaceType DimExprs [Dims]
  #new PrimitiveType Dims ArrayInitializer
  #new ClassOrInterfaceType Dims ArrayInitializer
#DimExprs:
  #DimExpr {DimExpr}
#DimExpr:
  #{Annotation} [ Expression ]
#Expression:
  #LambdaExpression
  #AssignmentExpression
#LambdaExpression:
  #LambdaParameters -> LambdaBody
#LambdaParameters:
  #Identifier
  #( [FormalParameterList] )
  #( InferredFormalParameterList )
#InferredFormalParameterList:
  #Identifier {, Identifier}
#LambdaBody:
  #Expression
  #Block
#AssignmentExpression:
  #ConditionalExpression
  #Assignment
#Assignment:
  #LeftHandSide AssignmentOperator Expression
#LeftHandSide:
  #ExpressionName
  #FieldAccess
  #ArrayAccess
#AssignmentOperator:
  #(one of)
  #=  *=  /=  %=  +=  -=  <<=  >>=  >>>=  &=  ^=  |=
#ConditionalExpression:
  #ConditionalOrExpression
  #ConditionalOrExpression ? Expression : ConditionalExpression
  #ConditionalOrExpression ? Expression : LambdaExpression
conditionalexpression = ConditionalOrExpression(conditionalorexpression coe)
      | ConditionalOrExpressionExp(conditionalorexpression coe, expression exp, conditionalexpression ce)
      | ConditionalOrExpressionLambda(conditionalorexpression coe, expression exp, lambdaexpression le)
#ConditionalOrExpression:
  #ConditionalAndExpression
  #ConditionalOrExpression || ConditionalAndExpression
conditionalorexpression = ConditionalAndExpression(conditionalandexpression cae)
      | ConditionalOrExpressionOr(conditionalorexpression coe, conditionalandexpression cae)
#ConditionalAndExpression:
  #InclusiveOrExpression
  #ConditionalAndExpression && InclusiveOrExpression
conditionalandexpression = InclusiveOrExpression(inclusiveorexpression ioe)
      | ConditionalAndExpressionAnd(conditionalandexpression cae, inclusiveorexpression ioe)
#InclusiveOrExpression:
  #ExclusiveOrExpression
  #InclusiveOrExpression | ExclusiveOrExpression
inclusiveorexpression = ExclusiveOrExpression(exclusiveorexpression eoe)
      | InclusiveOrExpressionOr(inclusiveorexpression ioe, exclusiveorexpression eoe)
#ExclusiveOrExpression:
  #AndExpression
  #ExclusiveOrExpression ^ AndExpression
exclusiveorexpression = AndExpression(andexpression ae)
      | ExclusiveOrExpressionOr(exclusiveorexpression eoe, andexpression ae)
#AndExpression:
  #EqualityExpression
  #AndExpression & EqualityExpression
andexpression = EqualityExpression(equalityexpression ee)
      | AndExpressionAnd(andexpression ae, equalityexpression ee)
#EqualityExpression:
  #RelationalExpression
  #EqualityExpression == RelationalExpression
  #EqualityExpression != RelationalExpression
equalityexpression = RelationalExpression(relationalexpression re)
      | EqualityExpressionEq(equalityexpression ee, relationalexpression re)
      | EqualityExpressionNe(equalityexpression ee, relationalexpression re)
#RelationalExpression:
  #ShiftExpression
  #RelationalExpression < ShiftExpression
  #RelationalExpression > ShiftExpression
  #RelationalExpression <= ShiftExpression
  #RelationalExpression >= ShiftExpression
  #RelationalExpression instanceof ReferenceType
relationalexpression = ShiftExpression(shiftexpression se)
      | RelationalExpressionLt(relationalexpression re, shiftexpression se)
      | RelationalExpressionGt(relationalexpression re, shiftexpression se)
      | RelationalExpressionLte(relationalexpression re, shiftexpression se)
      | RelationalExpressionGte(relationalexpression re, shiftexpression se)
#ShiftExpression:
  #AdditiveExpression
  #ShiftExpression << AdditiveExpression
  #ShiftExpression >> AdditiveExpression
  #ShiftExpression >>> AdditiveExpression
shiftexpression = AdditiveExpression(additiveexpression ae)
      | ShiftExpressionLeft(shiftexpression se, additiveexpression ae)
      | ShiftExpressionRight(shiftexpression se, additiveexpression ae)
      | ShiftExpressionRightThree(shiftexpression se, additiveexpression ae)
#AdditiveExpression:
  #MultiplicativeExpression
  #AdditiveExpression + MultiplicativeExpression
  #AdditiveExpression - MultiplicativeExpression
additiveexpression = MultiplicativeExpression(multiplicativeexpression me)
      | AdditiveExpressionPlus(additiveexpression ae, multiplicativeexpression me)
      | AdditiveExpressionMinus(additiveexpression ae, multiplicativeexpression me)
#MultiplicativeExpression:
  #UnaryExpression
  #MultiplicativeExpression * UnaryExpression
  #MultiplicativeExpression / UnaryExpression
  #MultiplicativeExpression % UnaryExpression
multiplicativeexpression = UnaryExpression(unaryexpression ue)
      | MultiplicativeExpressionMult(multiplicativeexpression me, unaryexpression ue)
      | MultiplicativeExpressionDiv(multiplicativeexpression me, unaryexpression ue)
      | MultiplicativeExpressionMod(multiplicativeexpression me, unaryexpression ue)
#UnaryExpression:
  #PreIncrementExpression
  #PreDecrementExpression
  #+ UnaryExpression
  #- UnaryExpression
  #UnaryExpressionNotPlusMinus
  #PostfixExpression
  #~ UnaryExpression
  #! UnaryExpression
  #CastExpression
unaryexpression = PreIncrementExpression(unaryexpression ue)
      | PreDecrementExpression(unaryexpression ue)
      | UnaryExpressionPlus(UnaryExpression ue)
      | UnaryExpressionMinus(UnaryExpression ue)
      | UnaryExpressionNotPlusMinus(unaryexpressionnotplusminus uenpm)
unaryexpressionnotplusminus = PostfixExpression(postfixexpression pe)
      | UnaryExpressionTilde(unaryexpression ue)
      | UnaryExpressionNot(unaryexpression ue)
      | CastExpression(castexpression ce)
#PreIncrementExpression:
  #++ UnaryExpression
#PreDecrementExpression:
  #-- UnaryExpression
#PostfixExpression:
  #Primary
  #ExpressionName
  #PostIncrementExpression
  #PostDecrementExpression
postfixexpression = Primary(primary p)
      | ExpressionName(expressionname en)
      | PostIncrementExpression(postfixexpression pe)
      | PostDecrementExpression(postfixexpression pe)
#PostIncrementExpression:
  #PostfixExpression ++
#PostDecrementExpression:
  #PostfixExpression --
#CastExpression:
  #( PrimitiveType ) UnaryExpression
  #( ReferenceType {AdditionalBound} ) UnaryExpressionNotPlusMinus
  #( ReferenceType {AdditionalBound} ) LambdaExpression
castexpression = ToPrimitiveType(primitivetype pt, unaryexpression ue)
      | ToReferenceTypeUnary(referencetype rt, additionalbound ab, unaryexpressionnotplusminus ue)
      | ToReferenceTypeLambda(referencetype rt, additionalbound ab, lambdaexpression le)
#ConstantExpression:
  #Expression
constantexpression = ConstantExpression(expression exp)

