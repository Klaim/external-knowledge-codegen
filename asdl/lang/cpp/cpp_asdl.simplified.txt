## ASDL's 4 builtin types are
identifier, int, string, constant

cu = TranslationUnit(statement* subnodes)

#dimension = ArrayDimension(expression? dim)

#annotation = MarkerAnnotation(identifier name)
#      | NormalAnnotation(expression* element, identifier name)
#      | SingleElementAnnotation(expression? element, identifier name)

#arrayinitializer = ArrayInitializer(expression* initializers, constant? comma)

#boolean = True | False

#tryresource = TryResource(fieldmodifier* modifiers, annotation* annotations, type type, identifier name, expression value)

#catch = CatchClause(identifier? label, catch_clause_parameter parameter, statement block)

#catch_clause_parameter = CatchClauseParameter(fieldmodifier* modifiers, annotation* annotations, identifier* types, identifier name)

#classbody = ClassBody(typedeclaration* declarations)
#      | EmptyClassBody

#declarator = VariableDeclarator(identifier name, dimension* dimensions, expression? initializer)

#expression = ArrayCreator(operator* prefix_operators, operator* postfix_operators, expression? qualifier, expression* selectors, type type, dimension* dimensions, arrayinitializer? initializer)
#      | ElementValueArrayInitializer(arrayinitializer initializer)
#      | ArraySelector(expression index)
#      | Assignment(operator* prefix_operators, operator* postfix_operators, expression? qualifier, expression* selectors, expression expressionl, expression value, operator type)
#      | Cast(operator* prefix_operators, operator* postfix_operators, expression? qualifier, expression* selectors, type type, expression expression)
#      | ClassCreator(operator* prefix_operators, operator* postfix_operators, expression? qualifier, expression* selectors, type type, type_argument* constructor_type_arguments, expression* arguments, classbody? body)
#      | ClassReference(operator* prefix_operators, operator* postfix_operators, expression? qualifier, expression* selectors, type type)
#      | Creator(operator* prefix_operators, operator* postfix_operators, expression? qualifier, expression* selectors, type type)
#      | ElementValuePair(identifier name, expression value)
#      | ExplicitConstructorInvocation(operator* prefix_operators, operator* postfix_operators, expression? qualifier, expression* selectors, type_argument* type_arguments, expression* arguments)
#      | Identifier(identifier id)
#      | InnerClassCreator(operator* prefix_operators, operator* postfix_operators, expression? qualifier, expression* selectors, type type, type_argument* constructor_type_arguments, expression* arguments, statement* body)
#      | Invocation(operator* prefix_operators, operator* postfix_operators, expression? qualifier, expression* selectors, type_argument* type_arguments, expression* arguments)
#      | LambdaExpression(parameter? parameter, parameter* parameters, expression body)
#      | Literal(operator* prefix_operators, operator* postfix_operators, expression? qualifier, expression* selectors, string value)
#      | FieldReference(operator* prefix_operators, operator* postfix_operators, expression? qualifier, expression* selectors, identifier field)
#      | MemberReference(operator* prefix_operators, operator* postfix_operators, expression? qualifier, expression* selectors, identifier member)
#      | MethodInvocation(operator* prefix_operators, operator* postfix_operators, expression? qualifier, expression* selectors, type_argument* type_arguments, expression* arguments, identifier member)
#      | MethodReference(expression expression, expression method, type_argument* type_arguments)
#      | NoExpression
#      | ReferenceTypeExpression(type type)
#      | SuperConstructorInvocation(operator* prefix_operators, operator* postfix_operators, expression? qualifier, expression* selectors, type_argument* type_arguments, expression* arguments)
#      | SuperMemberReference(operator* prefix_operators, operator* postfix_operators, expression? qualifier, expression* selectors, identifier member)
#      | SuperMethodInvocation(operator* prefix_operators, operator* postfix_operators, expression? qualifier, expression* selectors, type_argument* type_arguments, expression* arguments, identifier member)
#      | TernaryExpression(operator* prefix_operators, operator* postfix_operators, expression? qualifier, expression* selectors, expression condition, expression if_true, expression if_false)
#      | VariableDeclaration(fieldmodifier* modifiers, annotation* annotations, type type, declarator* declarators)
#      | VariableInitializer(expression? expression, arrayinitializer? array)
#      | VoidClassReference(operator* prefix_operators, operator* postfix_operators, expression? qualifier, expression* selectors)

#fieldmodifier = Modifier(constant value)

#forcontrol = EnhancedForControl(expression var, expression iterable)
#      | ForControl(expression* init, expression? condition, expression* update)

#importdeclaration = Import(identifier path, constant? static, constant? wildcard)

#localvariable = LocalVariableDeclaration(fieldmodifier* modifiers, annotation* annotations, type type, declarator* declarators)

#operator = Operator(constant operator)

#parameter = FormalParameter(annotation* annotations, fieldmodifier* modifiers, identifier name, type type, dimension* dimensions, constant? varargs)
#      | InferredFormalParameter(expression expression)

statement = AccessSpecDecl(identifier access_spec)
      | BreakStmt(statement* subnodes)
      | BinaryOperator(constant opcode, statement* subnodes)
      | CallExpr(statement* subnodes)
      | CaseStmt(statement* subnodes)
      | CharacterLiteral(identifier value)
      | ClassTemplateDecl(statement* subnodes)
      | CompoundStmt(statement* subnodes)
      | ConstantExpr(identifier value, statement* subnodes)
      | ContinueStmt(statement* subnodes)
      | CStyleCastExpr(identifier type, statement* subnodes)
      | CXXBindTemporaryExpr(statement* subnodes)
      | CXXBoolLiteralExpr(constant value)
      | CXXConstructExpr(identifier type, statement* subnodes)
      | CXXConstructorDecl(identifier name, identifier noexcept, identifier default, statement* subnodes)
      | CXXConversionDecl(identifier name, statement* subnodes)
      | CXXCtorInitializer(identifier name, statement* subnodes)
      | CXXDefaultArgExpr
      | CXXDestructorDecl(identifier name, constant virtual, constant default, constant noexcept, statement* subnodes)
      | CXXFunctionalCastExpr(identifier type, statement* subnodes)
      | CXXMemberCallExpr(statement* subnodes)
      | CXXMethodDecl(string? documentation, identifier name, constant virtual, identifier return_type, identifier noexcept, identifier const, identifier default, statement* subnodes)
      | CXXOperatorCallExpr(statement left, statement op, statement right)
      | CXXRecordDecl(identifier name, identifier kind, identifier bases, statement* subnodes)
      | CXXTemporaryObjectExpr(identifier type, statement* subnodes)
      | CXXThisExpr(statement* subnodes)
      | DeclRefExpr(identifier name, identifier kind, statement* subnodes)
      | DeclStmt(statement* subnodes)
      | DefaultStmt(statement* subnodes)
      | EmptyDecl
      | EnumConstantDecl(identifier name, statement* subnodes)
      | EnumDecl(identifier name, statement* subnodes)
      | ExprWithCleanups(statement* subnodes)
      | FieldDecl(identifier name, identifier type, statement* subnodes)
      | FloatingLiteral(identifier value)
      | ForStmt(statement* subnodes)
      | FriendDecl(identifier type)
      | FullComment(string comment)
      | FunctionDecl(string? documentation, identifier name, identifier return_type, statement* subnodes)
      | FunctionTemplateDecl(statement* subnodes)
      | IfStmt(statement* subnodes)
      | IntegerLiteral(identifier value)
      | ImplicitCastExpr(statement* subnodes)
      | ImplicitValueInitExpr(statement* subnodes)
      | InitListExpr(statement* subnodes)
      | MaterializeTemporaryExpr(statement* subnodes)
      | MemberExpr(identifier name, identifier op, statement* subnodes)
      | NamespaceDecl(identifier name, statement* subnodes)
      | NonTypeTemplateParmDecl(identifier name, identifier type, statement* subnodes)
      | NullStmt
      | OverrideAttr
      | ParenExpr(statement* subnodes)
      | ParmVarDecl(identifier name, identifier type, statement* subnodes)
      | ReturnStmt(statement* subnodes)
      | StringLiteral(identifier value)
      | SwitchStmt(statement* subnodes)
      | TemplateTypeParmDecl(identifier name, statement* subnodes)
      | TypeRef(identifier name)
      | UnaryOperator(constant opcode, constant postfix, statement* subnodes)
      | UsingDirectiveDecl(identifier name)
      | VarDecl(identifier name, identifier type, identifier storage_class, identifier array, identifier init, statement* subnodes)

#      | BasicType(identifier name, dimension* dimensions)
#      | DiamondType(identifier name, dimension* dimensions, type? sub_type)
#      | ReferenceType(identifier name, dimension* dimensions, type_argument* arguments, type? sub_type)

#type_argument = TypeArgument(type? type, identifier? pattern_type)

#typedeclaration = AnnotationDeclaration(fieldmodifier* modifiers, annotation* annotations, string? documentation, identifier name, typedeclaration* body)
#      | AnnotationMethod(fieldmodifier* modifiers, annotation* annotations, identifier name, type? return_type, dimension* dimensions, identifier? default)
#      | ClassDeclaration(annotation* annotations, typedeclaration* body, string? documentation, type? extends, type* implements, fieldmodifier* modifiers, identifier name, type_parameter* type_parameters)
#      | ConstantDeclaration(string? documentation, fieldmodifier* modifiers, annotation* annotations, type type, declarator* declarators)
#      | ConstructorDeclaration(fieldmodifier* modifiers, annotation* annotations, string? documentation, type_parameter* type_parameters, identifier name, parameter* parameters, identifier* throws, statement body)
#      | EmptyDeclaration(string? documentation)
#      | FieldDeclaration(string? documentation, fieldmodifier* modifiers, annotation* annotations, type type, declarator* declarators)
#      | InstanceInitializer(statement block)
#      | InterfaceDeclaration(annotation* annotations, string? documentation, fieldmodifier* modifiers, identifier name, type_parameter* type_parameters, type* extends, typedeclaration* body)
#      | MethodDeclaration(string? documentation, fieldmodifier* modifiers, annotation* annotations, type_parameter* type_parameters, type? return_type, identifier name, dimension* dimensions, parameter* parameters, identifier* throws, statement? body)
#      | StaticInitializer(statement block)

#type_parameter = TypeParameter(identifier name, type* extends)

