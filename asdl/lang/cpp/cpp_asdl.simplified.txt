## ASDL's 4 builtin types are
identifier, int, string, constant

cu = TranslationUnit(statement* subnodes)

statement = AccessSpecDecl(identifier access_spec)
      | BreakStmt
      | CXXConstructorDecl(identifier name, identifier noexcept, identifier default, statement* subnodes)
      | CXXConversionDecl(identifier name, statement* subnodes)
      | CXXCtorInitializer(identifier name, statement* subnodes)
      | CXXDestructorDecl(identifier name, constant virtual, constant default, constant noexcept, statement* subnodes)
      | CXXForRangeStmt(statement* subnodes)
      | CXXMethodDecl(string? documentation, identifier name, constant virtual, identifier return_type, identifier noexcept, identifier const, identifier default, statement* subnodes)
      | CXXRecordDecl(identifier name, identifier kind, identifier bases, constant complete_definition, statement* subnodes)
      | CaseStmt(expression pattern, statement stmt)
      | ClassTemplateDecl(statement* subnodes)
      | CompoundStmt(statement* subnodes)
      | ContinueStmt
      | DeclStmt(statement* subnodes)
      | DefaultStmt(statement stmt)
      | DoStmt(expression cond, statement body)
      | EmptyDecl
      | EnumDecl(identifier? name, enum_field* subnodes)
      | ExprStmt(expression expr)
      | ExprWithCleanups(statement* subnodes)
      | FieldDecl(identifier name, type type, expression? init)
      | ForStmt(expression? init, expression? cond, expression? inc, statement body)
      | FriendDecl(identifier type)
      | GotoStmt(identifier target)
      | FullComment(string comment)
      | FunctionDecl(string? documentation, identifier name, type return_type, statement* subnodes, constant? storage, constant? variadic, constant? inline)
      | FunctionTemplateDecl(statement* subnodes)
      | IfStmt(expression cond, statement true_body, statement? false_body)
      | LabelStmt(identifier name, statement stmt)
      | NamespaceDecl(identifier name, statement* subnodes)
      | NonTypeTemplateParmDecl(identifier name, identifier type, statement* subnodes)
      | NullStmt
      | OverrideAttr
      | ParmVarDecl(identifier? name, type type, statement* subnodes)
      | ReturnStmt(expression? value)
      | SwitchStmt(expression cond, statement body)
      | TemplateTypeParmDecl(identifier name, statement* subnodes)
      | TypeRef(identifier name)
      | TypedefDecl(identifier name, type type)
      | UsingDirectiveDecl(identifier name)
      | VarDecl(identifier name, type type, constant? storage_class, constant init_mode, constant? implicit, constant? referenced, expression* subnodes)
      | WhileStmt(expression cond, statement body)

expression =  ArraySubscriptExpr(expression base, expression index)
      | BinaryOperator(constant opcode, expression left, expression right)
      | CStyleCastExpr(type type, expression expr)
      | ConditionalOperator(expression cond, expression true_expr, expression false_expr)
      | CXXBindTemporaryExpr(expression* subnodes)
      | CXXBoolLiteralExpr(constant value)
      | CXXConstructExpr(identifier type, expression* subnodes)
      | CXXDefaultArgExpr
      | CXXFunctionalCastExpr(identifier type, expression* subnodes)
      | CXXMemberCallExpr(expression* subnodes)
      | CXXNewExpr(expression* subnodes)
      | CXXNullPtrLiteralExpr
      | CXXOperatorCallExpr(expression left, expression op, expression right)
      | CXXStdInitializerListExpr(expression* subnodes)
      | CXXTemporaryObjectExpr(identifier type, expression* subnodes)
      | CXXThisExpr(expression* subnodes)
      | CallExpr(expression* subnodes)
      | CharacterLiteral(identifier value)
      | ConstantExpr(identifier value, expression expr)
      | DeclRefExpr(identifier name, identifier kind, expression* subnodes)
      | FloatingLiteral(identifier type, identifier value)
      | ImplicitCastExpr(type type, expression expr)
      | ImplicitValueInitExpr(expression* subnodes)
      | InitListExpr(expression* subnodes)
      | IntegerLiteral(identifier type, identifier value)
      | MaterializeTemporaryExpr(expression* subnodes)
      | MemberExpr(identifier name, identifier op, expression expr)
      | ParenExpr(expression expr)
      | StringLiteral(identifier value)
      | UnaryExprOrTypeTraitExpr(identifier name, expression? expr, type? type)
      | UnaryOperator(constant opcode, constant postfix, expression expr)

type = BuiltinType(identifier name)
     | ConstantArrayType(type type, constant size)
     | DecayedType(type type)
     | ElaboratedType(type type, identifier? qualifiers)
     | EnumType(identifier name)
     | FunctionProtoType(type* subnodes)
     | IncompleteArrayType(type type)
     | LValueReferenceType(type type)
     | ParenType(type type)
     | PointerType(type type)
     | RecordType(identifier name)
     | RValueReferenceType(type type)
     | QualType(identifier? qualifiers, type* subnodes)

enum_field = EnumConstantDecl(identifier name, expression? init)
